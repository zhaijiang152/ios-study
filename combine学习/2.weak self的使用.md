这是一个**至关重要**的 Swift 内存管理实践。使用 `[weak self]`是为了**防止循环引用（Retain Cycle）和内存泄漏（Memory Leak）**。

### 问题的核心：循环引用

在你的代码中，存在一个潜在的循环引用关系：

```swift
viewModel.$isOnboardingFinished.sink { [weak self] success in
    if success {
        self?.dismiss(animated: true)
    }
}
// .store(in: &cancellables) // 假设这个 cancellable 被 ViewController 持有
```

1. **`self`(ViewController)** 持有着 `cancellable`（通过 `store(in: &cancellables)`）。
2. **`cancellable`** 持有着 `sink`返回的订阅，该订阅**强烈捕获（strongly capture）了 closure 内的所有内容**。
3. 如果 closure 内使用了 `self`而没有标记为 `weak`，那么 **closure 就会强烈持有 `self`**。

这就形成了一个致命的循环：

**ViewController → Cancellable → Closure → ViewController**

由于它们互相强引用，**即使你从导航栈中 dismiss 了这个 ViewController，它的内存也永远不会被释放**。这就是内存泄漏。

### `[weak self]`的作用

`[weak self]`创建了一个对 `self`的**弱引用（weak reference）**。

- **弱引用不会增加对象的引用计数**。
- 当 `self`（ViewController）被销毁时，弱引用会自动变为 `nil`。
- 这打破了循环引用链：**ViewController → Cancellable → Closure ─weak─> ViewController**

现在，当 ViewController 被销毁时，因为没有强引用指向它，内存可以被正确释放。随后，`cancellable`也会被释放，整个订阅关系会被清理。

------

### 如果不使用 `[weak self]`会怎样？

```swift
// ❌ 危险代码：可能导致内存泄漏
viewModel.$isOnboardingFinished.sink { success in // 隐式强捕获 self
    if success {
        self.dismiss(animated: true) // 这里编译器会警告：Reference to property 'dismiss' in closure requires explicit use of 'self' to make capture semantics explicit
    }
}
```

如果你按照警告提示添加 `self`：

```swift
// ❌ 危险代码：明确导致了内存泄漏
viewModel.$isOnboardingFinished.sink { [self] success in // 显式强捕获 self
    if success {
        self.dismiss(animated: true)
    }
}
```

这两种写法都会导致上面描述的**循环引用**。你的 ViewController 会永远留在内存中。

------

### 如何在 Closure 内安全使用 `self`

使用 `[weak self]`后，`self`在 closure 内部变成了一个**可选类型（Optional）**，所以你必须使用 `?`或 `!`来解包。

**推荐方式（安全解包）：**

```swift
.sink { [weak self] success in
    // 使用可选链式调用（optional chaining）
    if success {
        self?.dismiss(animated: true) // 如果 self 已不存在，这行代码什么也不会做
    }
}
```

**另一种方式（guard let 提前退出）：**

```swift
.sink { [weak self] success in
    guard let self = self else { return } // 如果 self 已被释放，立即退出
    if success {
        self.dismiss(animated: true) // 这里 self 是强引用，但闭包很快会执行完，循环被打破是暂时的，没问题
    }
}
```

### 总结：何时需要使用 `[weak self]`？

**一个简单的判断法则：**

> 当你将一个 closure 存储起来（例如赋值给一个属性、添加到集合中、被一个长期存在的对象持有），而这个 closure 内部又捕获了 `self`时，**就必须使用 `[weak self]`**。

在 Combine 中，`.sink`返回的 `AnyCancellable`**必须被存储**（否则订阅会立即取消），所以它符合这个条件。因此，在 `sink`的 closure 里捕获 `self`时，**总是应该使用 `[weak self]`**。